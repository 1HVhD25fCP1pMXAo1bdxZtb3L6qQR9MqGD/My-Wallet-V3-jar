package info.blockchain.wallet.metadata;

import info.blockchain.api.MetadataEndpoints;
import info.blockchain.wallet.exceptions.SharedMetadataConnectionException;
import info.blockchain.wallet.exceptions.ValidationException;
import info.blockchain.wallet.metadata.data.Auth;
import info.blockchain.wallet.metadata.data.Contact;
import info.blockchain.wallet.metadata.data.Invitation;
import info.blockchain.wallet.metadata.data.Message;
import info.blockchain.wallet.metadata.data.PaymentRequest;
import info.blockchain.wallet.metadata.data.PaymentRequestResponse;
import info.blockchain.wallet.metadata.data.PublicContactDetails;
import info.blockchain.wallet.metadata.data.Trusted;
import info.blockchain.wallet.util.MetadataUtil;

import org.bitcoinj.core.ECKey;
import org.bitcoinj.crypto.DeterministicKey;
import org.bitcoinj.params.MainNetParams;
import org.spongycastle.util.encoders.Base64;

import java.io.IOException;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.Response;


public class SharedMetadata extends Metadata{

    final int TYPE_PAYMENT_REQUEST = 1;
    final int TYPE_PAYMENT_REQUEST_RESPONSE = 2;

    String token;

    public SharedMetadata() {
        //noop
    }

    public void setEndpoints(MetadataEndpoints endpoints) {
        this.endpoints = endpoints;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void setNode(DeterministicKey node) {
        this.node = node;
    }

    public DeterministicKey getNode() {
        return node;
    }

    public String getAddress() {
        return this.address;
    }

    public String getXpub() {
        return node.serializePubB58(MainNetParams.get());
    }

    /**
     * Do auth challenge
     */
    public void authorize() throws SharedMetadataConnectionException, IOException {
        this.token = getToken();
    }

    /**
     * Get nonce generated by the server (auth challenge).
     */
    private String getNonce() throws SharedMetadataConnectionException, IOException {

        Call<Auth> response = endpoints.getNonce();

        Response<Auth> exe = response.execute();

        if (exe.isSuccessful()) {
            return exe.body().getNonce();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Get JSON Web Token if signed nonce is correct. Signed.
     */
    private String getToken() throws SharedMetadataConnectionException, IOException {

        String nonce = getNonce();
        String sig = node.signMessage(nonce);

        HashMap<String, String> map = new HashMap<>();
        map.put("mdid", address);
        map.put("signature", sig);
        map.put("nonce", nonce);
        Call<Auth> response = endpoints.getToken(map);

        Response<Auth> exe = response.execute();

        if (exe.isSuccessful()) {
            return exe.body().getToken();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Get list of all trusted MDIDs. Authenticated.
     */
    public Trusted getTrustedList() throws SharedMetadataConnectionException, IOException {

        Call<Trusted> response = endpoints.getTrustedList("Bearer " + token);

        Response<Trusted> exe = response.execute();

        if (exe.isSuccessful()) {
            return exe.body();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Check if a contact is on trusted list of mdid. Authenticated.
     */
    public boolean getTrusted(String mdid) throws SharedMetadataConnectionException, IOException {

        Call<Trusted> response = endpoints.getTrusted("Bearer " + token, mdid);

        Response<Trusted> exe = response.execute();

        if (exe.isSuccessful()) {
            return Arrays.asList(exe.body().getContacts()).contains(mdid);
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Add a contact to trusted list of mdid. Authenticated.
     */
    public boolean putTrusted(String mdid) throws SharedMetadataConnectionException, IOException {

        Call<Trusted> response = endpoints.putTrusted("Bearer " + token, mdid);

        Response<Trusted> exe = response.execute();

        if (exe.isSuccessful()) {
            return mdid.equals(exe.body().getContact());
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Delete a contact from trusted list of mdid. Authenticated.
     */
    public boolean deleteTrusted(String mdid) throws SharedMetadataConnectionException, IOException {

        Call<ResponseBody> response = endpoints.deleteTrusted("Bearer " + token, mdid);

        Response<ResponseBody> exe = response.execute();

        if (exe.isSuccessful()) {
            return true;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Add new shared metadata entry. Signed. Authenticated.
     */
    private Message postMessage(String mdidRecipient, String message, int type) throws Exception {

        String recipientXpub = getPublicXpubFromMdid(mdidRecipient);

        byte[] encryptedMessage = MetadataUtil.encryptFor(node, recipientXpub, message);

        String b64Msg = new String(Base64.encode(encryptedMessage));

        String signature = node.signMessage(b64Msg);

        Message request = new Message();
        request.setRecipient(mdidRecipient);
        request.setType(type);
        request.setPayload(b64Msg);
        request.setSignature(signature);

        Call<Message> response = endpoints.postMessage("Bearer " + token, request);

        Response<Message> exe = response.execute();

        if (exe.isSuccessful()) {
            return exe.body();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }

    }

    /**
     * Get messages sent to my MDID. Authenticated.
     */
    private List<Message> getMessages(boolean onlyProcessed) throws Exception {

        Call<List<Message>> response = endpoints.getMessages("Bearer " + token, onlyProcessed);

        Response<List<Message>> exe = response.execute();

        if (exe.isSuccessful()) {

            for (Message msg : exe.body()) {
                verifiedAndDecryptMessage(msg);
            }

            return exe.body();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Get messages sent to my MDID. Authenticated.
     */
    private List<Message> getMessages(String lastMessageId) throws Exception {

        Call<List<Message>> response = endpoints.getMessages("Bearer " + token, lastMessageId);

        Response<List<Message>> exe = response.execute();

        if (exe.isSuccessful()) {

            for (Message msg : exe.body()) {
                verifiedAndDecryptMessage(msg);
            }

            return exe.body();
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Get message from message id. Authenticated.
     */
    private Message getMessage(String messageId) throws Exception {

        Call<Message> response = endpoints.getMessage("Bearer " + token, messageId);

        Response<Message> exe = response.execute();

        if (exe.isSuccessful()) {

            Message msg = exe.body();
            verifiedAndDecryptMessage(msg);
            return msg;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    public Message sendPaymentRequest(String mdid, PaymentRequest paymentRequest) throws Exception {
        return postMessage(mdid, paymentRequest.toJson(), TYPE_PAYMENT_REQUEST);
    }

    public Message acceptPaymentRequest(String mdid, PaymentRequest paymentRequest, String note, String receiveAddress) throws Exception {

        PaymentRequestResponse response = new PaymentRequestResponse();
        response.setAmount(paymentRequest.getAmount());
        response.setNote(note);
        response.setAddress(receiveAddress);

        return postMessage(mdid, response.toJson(), TYPE_PAYMENT_REQUEST_RESPONSE);
    }

    public List<PaymentRequest> getPaymentRequests(boolean onlyProcessed) throws Exception {

        List<PaymentRequest> requests = new ArrayList<>();

        List<Message> messages = getMessages(onlyProcessed);

        for (Message message : messages) {

            if (message.getType() == TYPE_PAYMENT_REQUEST) {
                requests.add(new PaymentRequest().fromJson(message.getPayload()));
            }
        }

        return requests;
    }

    public List<PaymentRequestResponse> getPaymentRequestResponses(boolean onlyProcessed) throws Exception {

        List<PaymentRequestResponse> responses = new ArrayList<>();

        List<Message> messages = getMessages(onlyProcessed);

        for (Message message : messages) {

            if (message.getType() == TYPE_PAYMENT_REQUEST_RESPONSE) {
                responses.add(new PaymentRequestResponse().fromJson(message.getPayload()));
            }
        }

        return responses;
    }

    /**
     * Verify message signature and return decrypted.
     */
    private void verifiedAndDecryptMessage(Message msg) throws Exception {

        validateSignature(msg);

        String senderXpub = getPublicXpubFromMdid(msg.getSender());

        String message = new String(Base64.decode(msg.getPayload()));
        msg.setPayload(MetadataUtil.decryptFrom(node, senderXpub, message));
    }

    private void validateSignature(Message msg) throws ValidationException, SignatureException {

        ECKey key = ECKey.signedMessageToKey(
                msg.getPayload(),
                msg.getSignature());

        String senderAddress = msg.getSender();
        String addressFromSignature = key.toAddress(MainNetParams.get()).toString();

        if (!senderAddress.equals(addressFromSignature)) {
            throw new ValidationException("Signature is not well-formed");
        }
    }

    /**
     * Obtains a one-time UUID for key sharing Gets MDID of sender from one-time UUID
     */
    public Invitation createInvitation() throws IOException, SharedMetadataConnectionException {

        Call<Invitation> response = endpoints.postShare("Bearer " + token);

        Response<Invitation> exe = response.execute();

        if (exe.isSuccessful()) {
            Invitation invitation = exe.body();
            return invitation;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Returns contact details of accepted invitation
     */
    public Contact acceptInvitation(String uri) throws SharedMetadataConnectionException, IOException {

        Map<String, String> queryParams = MetadataUtil.getQueryParams(uri);

        Call<Invitation> response = endpoints.postToShare("Bearer " + token, queryParams.get("id"));

        Response<Invitation> exe = response.execute();

        if (exe.isSuccessful()) {
            Invitation inv = exe.body();

            Contact contact = new Contact().fromQueryParameters(queryParams);
            contact.mdid = inv.getContact();
            return contact;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Gets MDID of sender from one-time UUID
     */
    public Contact readInvitation(String uuid) throws SharedMetadataConnectionException, IOException {

        Call<Invitation> response = endpoints.getShare("Bearer " + token, uuid);

        Response<Invitation> exe = response.execute();

        if (exe.isSuccessful()) {

            Contact contact = new Contact();// TODO: 08/12/2016 I have no further contact details here?
            contact.mdid = exe.body().getContact();
            return contact;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Deletes one-time UUID
     */
    public boolean deleteInvitation(String uuid) throws SharedMetadataConnectionException, IOException {

        Call<Invitation> response = endpoints.deleteShare("Bearer " + token, uuid);

        Response<Invitation> exe = response.execute();

        if (exe.isSuccessful()) {
            return true;
        } else {
            throw new SharedMetadataConnectionException(exe.code() + " " + exe.message());
        }
    }

    /**
     * Publish xpub (public readable)
     */
    public void publishXpub() throws Exception {

        setEncrypted(false);
        fetchMagic();
        putMetadata(new PublicContactDetails(getXpub()).toJson());
    }

    /**
     * Get public xpub for specified mdid
     */
    public String getPublicXpubFromMdid(String mdid) throws Exception {

        PublicContactDetails publicXpub = new PublicContactDetails().fromJson(getMetadata(mdid));
        return publicXpub.getXpub();
    }

    static class Builder{

        //Required
        private MetadataEndpoints endpoints;
        private DeterministicKey rootNode;

        public Builder(MetadataEndpoints endpoints, DeterministicKey rootNode){
            this.endpoints = endpoints;
            this.rootNode = rootNode;
        }

        /**
         * purpose' / type' / 0' : https://meta.blockchain.info/{address} - signature used to authorize
         * purpose' / type' / 1' : sha256(private key) used as 256 bit AES key
         */
        public SharedMetadata build() throws Exception {

            int purposeI = MetadataUtil.getPurposeMdid();

            DeterministicKey node = MetadataUtil.deriveHardened(rootNode, purposeI);

            SharedMetadata metadata = new SharedMetadata();
            metadata.setEndpoints(endpoints);
            metadata.setAddress(node.toAddress(MainNetParams.get()).toString());
            metadata.setNode(node);
            metadata.authorize();
            metadata.publishXpub();

            return metadata;
        }
    }
}